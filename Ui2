/* Unified Rain Claim + STOMP/WS Hooks
   - Standalone script to run on page load or via Snippets tab
   - Posts structured messages via postMessage for overlay consumption
   - Exposes window.NI_RAIN API: start(), stop(), runOnce(), status()
   - Designed to be safe: will not silently exfiltrate data; use responsibly
*/
(function NI_Rain_Global(){
  if (window.__NI_RAIN_LOADED__) return;
  window.__NI_RAIN_LOADED__ = true;

  // ================== CONFIG ==================
  const cfg = {
    autostart: false,              // if true, starts the recurring claim loop on load
    intervalMs: 30_000,            // default loop interval
    maxRetries: 3,
    baseDelayMs: 800,
    timeoutMs: 12_000,
    preferFetch: true,
    followRedirect: true,
    claimEndpoint: null,           // override endpoint (string). If null, auto-derive
    method: "POST",
    headers: { "Content-Type": "application/json" },
    expectJsonResponse: true,
    wsFallback: false,             // try WS fallback if HTTP fails
    wsUrl: null,                   // optional WS url for fallback
    wsPayload: null,               // optional WS payload for fallback
    verbose: false,                // extra console logging
  };

  // volatile runtime state
  const state = {
    running: false,
    timer: null,
    stats: { attempts: 0, successes: 0 },
    lastResult: null
  };

  // ================== UTILITIES ==================
  const nowIso = () => new Date().toISOString();

  function logLocal(type, payload){
    const message = { ni: true, source: 'rain', type, payload, ts: nowIso() };
    try {
      window.postMessage(message, '*');
      if (window.top && window.top !== window) {
        // also post to top for overlays living in top window
        try { window.top.postMessage(message, '*'); } catch(e) {}
      }
    } catch(e){ /* ignore */ }
    if (cfg.verbose) console.debug("[NI_RAIN]", type, payload);
  }

  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

  function promiseTimeout(p, ms){
    let id;
    const timeout = new Promise((_, reject) => id = setTimeout(()=>reject(new Error("timeout")), ms));
    return Promise.race([p, timeout]).finally(()=> clearTimeout(id));
  }

  function backoffDelay(attempt){
    const base = cfg.baseDelayMs * Math.pow(1.8, attempt);
    return base + Math.floor(Math.random() * (base * 0.3));
  }

  // safe previewer for bodies (stringify / text)
  function previewBody(b, max=800){
    try {
      if (b === undefined || b === null) return null;
      if (typeof b === 'string') return b.length > max ? b.slice(0,max) + '...' : b;
      if (b instanceof Blob || b instanceof ArrayBuffer || ArrayBuffer.isView(b)) return `[Binary ${b.size || b.byteLength || 'N/A'}]`;
      // try JSON
      return JSON.stringify(b).slice(0, max) + (JSON.stringify(b).length > max ? '...' : '');
    } catch(e){ return String(b).slice(0, max); }
  }

  // ================== NETWORK ATTEMPT HELPERS ==================
  async function attemptFetch(url, body, headers, method){
    const opts = { method: method || cfg.method, headers: headers || cfg.headers, cache: "no-store", redirect: cfg.followRedirect ? "follow" : "manual" };
    if (body !== undefined && body !== null) opts.body = body;
    const resp = await promiseTimeout(fetch(url, opts), cfg.timeoutMs);
    const status = resp.status;
    let text = null, json = null;
    try { text = await resp.clone().text().catch(()=>null); } catch(e){}
    try { json = await resp.clone().json().catch(()=>null); } catch(e){}
    return { status, text, json, resp };
  }

  function attemptXHR(url, body, headers, method){
    return new Promise((resolve, reject) => {
      try {
        const xhr = new XMLHttpRequest();
        xhr.open(method || cfg.method, url, true);
        for (const k in (headers || {})) try { xhr.setRequestHeader(k, headers[k]); } catch(e){}
        xhr.timeout = cfg.timeoutMs;
        xhr.onload = () => resolve({ status: xhr.status, text: xhr.responseText, resp: xhr });
        xhr.onerror = () => reject(new Error("xhr error"));
        xhr.ontimeout = () => reject(new Error("xhr timeout"));
        xhr.send(body === undefined ? null : body);
      } catch (e) { reject(e); }
    });
  }

  // heuristic for success (tune per-site)
  function defaultSuccessHeuristic(text, status, json){
    if (status >= 200 && status < 300) return true;
    if (json && (json.success || json.result === "ok" || json.status === "ok")) return true;
    if (typeof text === "string" && /success|claimed|ok|won/i.test(text)) return true;
    return false;
  }

  // try to auto-derive endpoint or body from page
  function autoDerive(){
    try {
      // common patterns
      if (window.claimUrl) return { url: window.claimUrl };
      if (window.__CLAIM_ENDPOINT) return { url: window.__CLAIM_ENDPOINT };
      // form-based
      const btn = document.querySelector('button[data-claim], button.claim, button[id*="claim"], [data-claim="true"]');
      if (btn && btn.form){
        const f = btn.form;
        const action = f.action || location.href;
        const data = new FormData(f);
        return { url: action, body: new URLSearchParams(data).toString(), headers: { "Content-Type": "application/x-www-form-urlencoded" }, method: "POST" };
      }
    } catch(e){}
    return {};
  }

  // orchestrate attempts with retries/backoff
  async function runAttemptOnce(opts = {}){
    const derived = autoDerive();
    const url = opts.claimEndpoint || cfg.claimEndpoint || derived.url || null;
    let body = opts.getBody ? await opts.getBody() : (derived.body || opts.body || null);
    let headers = Object.assign({}, cfg.headers, derived.headers || {}, opts.headers || {});
    const method = opts.method || cfg.method || derived.method || "POST";

    if (!url) {
      logLocal('claim_result', { id: null, success:false, info: 'no-endpoint', ts: nowIso() });
      return { success:false, reason: 'no-endpoint' };
    }

    const runId = `ni-rain-${Date.now().toString(36)}-${Math.random().toString(36).slice(2,8)}`;
    logLocal('claim_attempt', { id: runId, cfg: { method, headers }, request: { url, method, bodyPreview: previewBody(body) }, ts: nowIso() });

    // attempt loop
    for (let attempt = 0; attempt < (opts.maxRetries || cfg.maxRetries || 3); attempt++){
      try {
        let sendBody = body;
        if (sendBody && typeof sendBody === 'object' && headers["Content-Type"] && headers["Content-Type"].includes("application/json")) {
          try { sendBody = JSON.stringify(sendBody); } catch(e){}
        }

        let res;
        if (cfg.preferFetch && window.fetch) res = await attemptFetch(url, sendBody, headers, method);
        else res = await attemptXHR(url, sendBody, headers, method);

        const ok = (opts.successHeuristic || defaultSuccessHeuristic)(res.text, res.status, res.json);
        const result = { id: runId, attempt, success: !!ok, info: ok ? 'claimed' : 'rejected', response: { status: res.status, textSnippet: (res.text||'').slice(0,1000), json: res.json||null }, ts: nowIso() };

        // stats
        state.stats.attempts++;
        if (ok) state.stats.successes++;

        logLocal('claim_result', result);
        state.lastResult = result;
        return result;
      } catch (err) {
        logLocal('claim_error', { id: runId, attempt, error: String(err), ts: nowIso() });
        const wait = backoffDelay(attempt);
        await sleep(wait);
        continue;
      }
    }

    // failed after retries
    const fail = { id: runId, success:false, info: 'failed_after_retries', ts: nowIso() };
    state.stats.attempts++;
    logLocal('claim_result', fail);
    state.lastResult = fail;
    return fail;
  }

  // optionally also do a WS fallback
  async function attemptWsFallback(payloadString){
    if (!cfg.wsFallback || !cfg.wsUrl) return { success:false, info: 'no-ws-fallback' };
    try {
      const wsRes = await new Promise((resolve, reject) => {
        try {
          const ws = new WebSocket(cfg.wsUrl);
          const t = setTimeout(()=>{ try{ ws.close(); }catch(e){}; reject(new Error("ws timeout")); }, cfg.timeoutMs);
          ws.addEventListener('open', ()=> ws.send(payloadString));
          ws.addEventListener('message', ev => { clearTimeout(t); resolve({ text: typeof ev.data === 'string' ? ev.data : null, data: ev.data }); });
          ws.addEventListener('error', e => { clearTimeout(t); reject(e); });
        } catch(e) { reject(e); }
      });
      const ok = /success|claimed|ok/i.test(wsRes.text || '');
      const resObj = { id: `ws-fallback-${Date.now().toString(36)}`, success: !!ok, info: 'ws_fallback', payload: wsRes, ts: nowIso() };
      if (ok) state.stats.successes++;
      state.stats.attempts++;
      logLocal('claim_result', resObj);
      return resObj;
    } catch (e) {
      logLocal('claim_result', { id: `ws-fallback-${Date.now().toString(36)}`, success:false, info: 'ws_fallback_error', error:String(e), ts: nowIso() });
      return { success:false, error:String(e) };
    }
  }

  // ================== WS/STOMP HOOKS ==================
  // Helpers to detect SockJS and STOMP frames and attach listening
  function tryPatchWebSocket(){
    try {
      if (!window.WebSocket) return;
      if (window.__NI_RAIN_WS_PATCHED__) return;
      window.__NI_RAIN_WS_PATCHED__ = true;

      const OrigWS = window.WebSocket;
      function wrapConstructor(url, protocols){
        const ws = protocols ? new OrigWS(url, protocols) : new OrigWS(url);
        tryPatchInstance(ws, url);
        return ws;
      }
      // copy prototype/props
      wrapConstructor.prototype = OrigWS.prototype;
      window.WebSocket = wrapConstructor;

      function tryPatchInstance(ws, url){
        if (!ws) return;
        const origSend = ws.send.bind(ws);
        ws.send = function(data){
          try {
            let preview = (typeof data === 'string') ? data.slice(0,1000) : `[binary ${data && data.byteLength? data.byteLength : 'N/A'}]`;
            logLocal('ws_send', { url, dataPreview: preview, binary: !(typeof data === 'string'), ts: nowIso() });
            // STOMP: if text and begins with STOMP commands, parse
            if (typeof data === 'string' && isLikelyStompFrame(data)) {
              const parsed = parseStompFrame(data);
              logLocal('stomp_frame', Object.assign({ url, direction: 'send' }, parsed));
            }
          } catch(e){}
          return origSend(data);
        };

        ws.addEventListener('message', function(ev){
          try {
            const d = ev.data;
            let preview = (typeof d === 'string') ? d.slice(0,1000) : `[binary ${d && d.byteLength? d.byteLength : 'N/A'}]`;
            logLocal('ws_recv', { url, dataPreview: preview, binary: !(typeof d === 'string'), ts: nowIso() });
            if (typeof d === 'string' && isLikelyStompFrame(d)) {
              const parsed = parseStompFrame(d);
              logLocal('stomp_frame', Object.assign({ url, direction: 'recv' }, parsed));
            }
          } catch(e){}
        });
      }

      // attempt to patch any already-open sockets (best-effort)
      try { const keys = Object.keys(window); for (const k of keys) { try { const v = window[k]; if (v && v instanceof OrigWS) tryPatchInstance(v, v.url || 'unknown'); } catch(e){} } } catch(e){}
    } catch(e) { console.warn("NI_RAIN WS patch failed", e); }
  }

  // naive STOMP detection (text frames starting with STOMP commands)
  function isLikelyStompFrame(txt){
    if (!txt || typeof txt !== 'string') return false;
    const head = txt.trim().slice(0,12).toUpperCase();
    return /^(CONNECT|SEND|MESSAGE|SUBSCRIBE|UNSUBSCRIBE|BEGIN|COMMIT|ABORT|ACK|NACK|DISCONNECT)/.test(head);
  }

  // simple STOMP frame parser (very permissive)
  function parseStompFrame(raw){
    try {
      // STOMP frame: COMMAND\nheader:val\n...\n\nBODY\0
      const r = raw;
      const firstNl = r.indexOf('\n');
      const command = r.slice(0, firstNl).trim();
      const rest = r.slice(firstNl+1);
      const parts = rest.split('\n\n');
      const headersPart = parts[0] || '';
      const bodyPart = parts.slice(1).join('\n\n').replace(/\0$/, '');
      const hdrLines = headersPart.split('\n').filter(Boolean);
      const headers = {};
      hdrLines.forEach(line => {
        const idx = line.indexOf(':');
        if (idx >= 0) { const k = line.slice(0, idx); const v = line.slice(idx+1); headers[k] = v; }
      });
      let parsedBody = bodyPart;
      try { parsedBody = JSON.parse(bodyPart); } catch(e){}
      return { command, headers, body: parsedBody, raw };
    } catch(e){ return { command: 'UNKNOWN', headers: {}, body: raw, raw }; }
  }

  // enable WS patch now
  tryPatchWebSocket();

  // also try to detect SockJS send pattern (sockjs wraps messages in arrays/base64) - we hook WS anyway

  // ================== API (start/stop/runOnce/status) ==================
  async function runOnce(opts = {}) {
    logLocal('status', { running: true, reason: 'manual-run', ts: nowIso() });
    const res = await runAttemptOnce(opts);
    if (!res.success && cfg.wsFallback && cfg.wsUrl && cfg.wsPayload) {
      try {
        const wsres = await attemptWsFallback(JSON.stringify(cfg.wsPayload));
        return wsres;
      } catch(e){}
    }
    return res;
  }

  async function startLoop(opts = {}) {
    if (state.running) return;
    state.running = true;
    logLocal('status', { running: true, reason: 'startLoop', ts: nowIso() });
    // immediate run then schedule
    (async function loop(){
      try {
        while (state.running) {
          state.stats.attempts = state.stats.attempts || 0;
          state.stats.successes = state.stats.successes || 0;
          // expose status to overlay (periodic)
          logLocal('status', { running: true, stats: state.stats, ts: nowIso() });
          await runOnce(opts);
          await sleep(opts.intervalMs || cfg.intervalMs || 30000);
        }
      } catch(e) {
        logLocal('status', { running: false, error: String(e), ts: nowIso() });
        state.running = false;
      }
    })();
  }

  function stopLoop(){
    state.running = false;
    logLocal('status', { running: false, reason: 'stopped', ts: nowIso() });
  }

  function status(){
    return { running: state.running, stats: state.stats, lastResult: state.lastResult };
  }

  // attach to window for UI control
  window.NI_RAIN = {
    start: (opts) => { startLoop(opts); return status(); },
    stop: () => { stopLoop(); return status(); },
    runOnce: (opts) => runOnce(opts),
    status,
    cfg,
    state
  };

  // ================== ON LOAD BEHAVIOR ==================
  // post an initial ready message with hooks detected
  (function announce(){
    logLocal('ready', { ts: nowIso(), msg: 'NI_RAIN ready', canPatchWS: !!window.WebSocket });
  })();

  // run auto-patch for WebSocket if not yet patched
  tryPatchWebSocket();

  // auto-start if configured
  if (cfg.autostart) {
    setTimeout(()=>{ window.NI_RAIN.start(); }, 400);
  }

  // ================== for debugging: expose helper to merge with overlay logs ==================
  // overlay can call window.postMessage({ ni:true, source:'overlay', type:'merge_request', payload:{ lastLogId: '...' }}, '*')
  window.addEventListener('message', (e) => {
    const m = e.data;
    if (!m || m.ni !== true) return;
    if (m.source === 'overlay' && m.type === 'ping') {
      logLocal('pong', { ts: nowIso(), info: 'pong from rain' });
    }
  });

})(); // end NI_Rain_Global wrapper

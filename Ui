// ==UserScript==
// @name         WS/STOMP Multi-Rain Auto-Claim (All‑Inclusive)
// @namespace    rain.auto.claim
// @version      1.0.0
// @description  Universal WS/STOMP hook with logging, anti-dup, throttling, reconnect, iframe reinject, and multi-rain strategy
// @match        *://*/*
// @run-at       document-start
// ==/UserScript==

(function () {
  'use strict';

  /*****************************************************************
   * 0) GLOBAL GUARDS
   *****************************************************************/
  if (window.__RAIN_AUTOSCRIPT__) return;
  window.__RAIN_AUTOSCRIPT__ = true;

  /*****************************************************************
   * 1) CONFIG
   *****************************************************************/
  const CONFIG = {
    MIN_CLAIM_DELAY: 350,        // ms between claim sends
    MAX_ACTIVE_RAIN: 3,          // strategy cap
    RECONNECT_MAX_TRIES: 10,
    RECONNECT_BASE_DELAY: 500,
    HEARTBEAT_GRACE_MS: 30000
  };

  /*****************************************************************
   * 2) STATE
   *****************************************************************/
  const state = {
    myPlayer: { id: null, name: null, avatar: null },
    autoEnabled: true,
    claimedRainIds: new Set(),
    stompConfirmed: new Set(),
    rainPool: new Map(),
    claimQueue: [],
    lastClaimTs: 0,
    queueRunning: false,
    stats: { seen: 0, claimed: 0, amount: 0 }
  };

  /*****************************************************************
   * 3) LOGGING (console + overlay-safe)
   *****************************************************************/
  function log(msg, level = 'info') {
    const p = '[RAIN]';
    if (level === 'warn') console.warn(p, msg);
    else if (level === 'ok') console.log(p, msg);
    else console.info(p, msg);
  }

  /*****************************************************************
   * 4) THROTTLED QUEUE
   *****************************************************************/
  function enqueue(fn) {
    state.claimQueue.push(fn);
    runQueue();
  }

  function runQueue() {
    if (state.queueRunning) return;
    if (!state.claimQueue.length) return;
    state.queueRunning = true;

    const wait = Math.max(0, CONFIG.MIN_CLAIM_DELAY - (Date.now() - state.lastClaimTs));
    setTimeout(() => {
      const task = state.claimQueue.shift();
      state.lastClaimTs = Date.now();
      try { task(); } catch (e) {}
      state.queueRunning = false;
      runQueue();
    }, wait);
  }

  /*****************************************************************
   * 5) MULTI‑RAIN STRATEGY
   *****************************************************************/
  function scoreRain(r) {
    const amt = r.amountPerPlayer || 0;
    const players = (r.placesInfo || []).length;
    const now = Date.now();
    const timeLeft = r.endTime ? Math.max(1, r.endTime - now) : 15000;
    const urgency = Math.min(2, 15000 / timeLeft);
    return amt * (1 / (players + 1)) * urgency;
  }

  function selectBestRains() {
    return [...state.rainPool.values()]
      .filter(r => r.isCanClaim)
      .sort((a, b) => scoreRain(b) - scoreRain(a))
      .slice(0, CONFIG.MAX_ACTIVE_RAIN);
  }

  /*****************************************************************
   * 6) CLAIM SENDER (STOMP)
   *****************************************************************/
  function nextPlace(rain) {
    const used = (rain.placesInfo || []).map(p => p.place).filter(Boolean);
    let p = 1; while (used.includes(p)) p++; return p;
  }

  function sendClaim(ws, rain, via) {
    if (!state.autoEnabled) return;
    if (!state.myPlayer.id) return;
    if (state.claimedRainIds.has(rain.id)) return;

    state.claimedRainIds.add(rain.id);

    enqueue(() => {
      const place = nextPlace(rain);
      const payload = {
        code: 200,
        rainId: rain.id,
        place,
        playerId: state.myPlayer.id,
        playerName: state.myPlayer.name,
        playerAvatar: state.myPlayer.avatar,
        isMe: true
      };

      const frame =
        'SEND\n' +
        'destination:/user/queue/chat.rain.claim\n' +
        'content-type:application/json\n\n' +
        JSON.stringify(payload) + '\u0000';

      try { ws.send(frame); } catch (e) { log('Send failed', 'warn'); }

      state.stats.claimed++;
      state.stats.amount += rain.amountPerPlayer || 0;
      log(`CLAIM → ${rain.id} (${via})`, 'ok');
    });
  }

  /*****************************************************************
   * 7) MESSAGE NORMALIZER (RAW / STOMP / BINARY)
   *****************************************************************/
  async function normalize(data) {
    if (typeof data === 'string') return data;
    if (data instanceof ArrayBuffer)
      return new TextDecoder().decode(data);
    if (data instanceof Blob)
      return new TextDecoder().decode(await data.arrayBuffer());
    return null;
  }

  function extractJSON(raw) {
    const m = raw && raw.match(/\{[\s\S]*\}$/);
    if (!m) return null;
    try { return JSON.parse(m[0]); } catch { return null; }
  }

  async function handleMessage(raw, ws) {
    const norm = await normalize(raw);
    if (!norm) return;
    const data = extractJSON(norm);
    if (!data) return;

    // player bootstrap
    if (data.code === 200 && data.playerId) {
      state.myPlayer.id = data.playerId;
      state.myPlayer.name = data.playerName || String(data.playerId);
      state.myPlayer.avatar = data.playerAvatar || null;
      log(`Player ${state.myPlayer.name} ready`, 'ok');
    }

    // rain list
    if (Array.isArray(data.messages)) {
      data.messages.forEach(m => {
        if (m.type === 'RAIN' && m.rainInfo) {
          state.stats.seen++;
          state.rainPool.set(m.rainInfo.id, m.rainInfo);
        }
      });

      const chosen = selectBestRains();
      chosen.forEach(r => sendClaim(ws, r, 'STRATEGY'));
    }

    // confirmation
    if (data.type === 'RAIN_CONFIRM' && data.payload) {
      state.stompConfirmed.add(data.payload.rainId);
      state.rainPool.delete(data.payload.rainId);
      log(`CONFIRM ${data.payload.rainId}`, 'ok');
    }
  }

  window.__RAIN_HANDLE_MESSAGE__ = handleMessage;

  /*****************************************************************
   * 8) UNIVERSAL WEBSOCKET HOOK + RECONNECT
   *****************************************************************/
  (function hookWS() {
    const Native = window.WebSocket;
    if (!Native) return;

    function wrap(ws) {
      if (ws.__RAIN_HOOKED__) return ws;
      ws.__RAIN_HOOKED__ = true;

      const add = ws.addEventListener;
      ws.addEventListener = function (t, fn, ...r) {
        if (t === 'message') {
          const w = async e => {
            try { handleMessage(e.data, ws); } catch {}
            try { fn.call(this, e); } catch {}
          };
          return add.call(this, t, w, ...r);
        }
        return add.call(this, t, fn, ...r);
      };
      return ws;
    }

    function HookedWS(...a) {
      const ws = wrap(new Native(...a));
      let tries = 0;

      ws.addEventListener('close', () => {
        if (tries++ >= CONFIG.RECONNECT_MAX_TRIES) return;
        const d = CONFIG.RECONNECT_BASE_DELAY * tries;
        setTimeout(() => {
          try { new HookedWS(...a); } catch {}
        }, d);
      });

      return ws;
    }

    HookedWS.prototype = Native.prototype;
    Object.assign(HookedWS, Native);
    window.WebSocket = HookedWS;
    log('WS hook installed', 'ok');
  })();

  /*****************************************************************
   * 9) IFRAME REINJECTION
   *****************************************************************/
  function injectInto(win) {
    try {
      if (!win || win.__RAIN_AUTOSCRIPT__) return;
      win.eval('(' + arguments.callee.caller.toString() + ')()');
    } catch {}
  }

  window.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('iframe').forEach(f => {
      f.addEventListener('load', () => injectInto(f.contentWindow));
    });
  });

  /*****************************************************************
   * 10) READY
   *****************************************************************/
  log('All‑inclusive rain script active', 'ok');
})();

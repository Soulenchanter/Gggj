// ==UserScript==
// @name         Rain Auto-Claim STOMP v4.4 (Overlay + iframe-safe + Reconnect)
// @namespace    https://example.local/rain
// @version      4.4.0
// @run-at       document-start
// @grant        none
// @all-frames   true
// ==/UserScript==

(() => {
'use strict';
if (window.__RAIN_FINAL__) return;
window.__RAIN_FINAL__ = true;

/* =========================
   Identity / context
========================= */
const FRAME_ID = Math.random().toString(36).slice(2);
const isTop = window.top === window;

/* =========================
   State
========================= */
const state = {
    subsByRain: new Map(),
    activeSubs: new Set()
};

const stats = {
    rainsSeen: 0,
    claimsAttempted: 0,
    claimsSucceeded: 0,
    claimsFailed: 0
};

const timing = {
    byRain: new Map() // rainId -> { seenAt, resultAt }
};

const pendingClaims = new Set();
let resubscribeQueued = false;
let lastMessageAt = performance.now();

/* =========================
   WebSocket reconnect state
========================= */
const wsState = {
    sockets: new WeakMap(),
    lastCloseAt: 0,
    reconnects: 0,
    totalDowntime: 0
};

/* =========================
   STOMP helpers
========================= */
function parseFrame(raw) {
    if (!raw || raw === '\n' || raw.indexOf('RAIN') === -1) return null;
    let i = raw.indexOf('\n');
    if (i === -1) return null;

    const cmd = raw.slice(0, i);
    const headers = {};
    let j = i + 1;

    while ((i = raw.indexOf('\n', j)) !== -1) {
        if (i === j) break;
        const line = raw.slice(j, i);
        const k = line.indexOf(':');
        if (k > 0) headers[line.slice(0, k)] = line.slice(k + 1);
        j = i + 1;
    }

    const bodyStart = j + 1;
    let body = raw.slice(bodyStart, raw.length - 1);

    if (body[0] === '{') {
        try { body = JSON.parse(body); } catch {}
    }

    return { cmd, headers, body };
}

function buildFrame(cmd, headers = {}, body = '') {
    const h = Object.entries(headers).map(([k,v])=>`${k}:${v}`).join('\n');
    return `${cmd}\n${h}\n\n${body}\0`;
}

/* =========================
   Core logic
========================= */
function handleFrame(frame, socket) {
    if (!frame || !frame.body) return;
    lastMessageAt = performance.now();

    if (frame.body.type === 'RAIN') {
        stats.rainsSeen++;
        const id = frame.body.rainInfo?.id;
        if (id && !timing.byRain.has(id)) {
            timing.byRain.set(id, { seenAt: performance.now() });
        }
    }

    if (frame.body.type === 'RAIN' && frame.body.rainInfo?.isCanClaim) {
        autoClaim(frame.body.rainInfo.id, socket);
    }

    if (frame.body.type === 'RAIN_CLAIMED') {
        stats.claimsSucceeded++;
        const t = timing.byRain.get(frame.body.rainId);
        if (t) t.resultAt = performance.now();
        pendingClaims.delete(frame.body.rainId);
        unsubscribeRain(frame.body.rainId, socket);
        resubscribe(socket);
    }

    if (frame.body.type === 'RAIN_CLAIM_FAILED') {
        stats.claimsFailed++;
        const t = timing.byRain.get(frame.body.rainId);
        if (t) t.resultAt = performance.now();
        pendingClaims.delete(frame.body.rainId);
    }
}

/* =========================
   Claim control
========================= */
function autoClaim(rainId, socket) {
    if (pendingClaims.has(rainId)) return;
    pendingClaims.add(rainId);

    stats.claimsAttempted++;
    const payload = JSON.stringify({ rainId });
    socket.send(buildFrame(
        'SEND',
        { destination: '/app/chat.rain.claim', 'content-length': payload.length },
        payload
    ));
}

function unsubscribeRain(rainId, socket) {
    const subId = state.subsByRain.get(rainId);
    if (!subId) return;
    socket.send(buildFrame('UNSUBSCRIBE', { id: subId }));
    state.subsByRain.delete(rainId);
    state.activeSubs.delete(subId);
}

function resubscribe(socket) {
    if (resubscribeQueued) return;
    resubscribeQueued = true;

    queueMicrotask(() => {
        resubscribeQueued = false;
        const id = `sub-${Date.now()}`;
        state.activeSubs.add(id);
        socket.send(buildFrame('SUBSCRIBE', {
            id,
            destination: '/topic/chat.rain'
        }));
    });
}

/* =========================
   WebSocket lifecycle hook
========================= */
(function hookWebSocketLifecycle() {
    const OrigWS = WebSocket;

    WebSocket = function(url, protocols) {
        const ws = protocols ? new OrigWS(url, protocols) : new OrigWS(url);
        const meta = { createdAt: performance.now(), openAt: 0, closeAt: 0 };
        wsState.sockets.set(ws, meta);

        ws.addEventListener('open', () => {
            meta.openAt = performance.now();
            if (wsState.lastCloseAt) {
                wsState.reconnects++;
                wsState.totalDowntime += (meta.openAt - wsState.lastCloseAt);
                wsState.lastCloseAt = 0;
            }
            state.activeSubs.clear();
            resubscribe(ws);
        });

        ws.addEventListener('close', () => {
            meta.closeAt = performance.now();
            wsState.lastCloseAt = meta.closeAt;
            pendingClaims.clear();
        });

        return ws;
    };

    WebSocket.prototype = OrigWS.prototype;
})();

/* =========================
   Passive hooks
========================= */
(function hookSend() {
    const patch = proto => {
        if (!proto || proto.send.__patched__) return;
        const orig = proto.send;

        Object.defineProperty(proto, 'send', {
            value(data) {
                try {
                    if (typeof data === 'string') {
                        const f = parseFrame(data);
                        if (f?.cmd === 'SUBSCRIBE' && f.headers?.id) {
                            state.activeSubs.add(f.headers.id);
                        }
                    }
                } catch {}
                return orig.call(this, data);
            },
            configurable: false
        });
        proto.send.__patched__ = true;
    };

    patch(WebSocket.prototype);
    if (window.SockJS) patch(SockJS.prototype);
})();

(function hookMessages() {
    const orig = EventTarget.prototype.addEventListener;
    if (orig.__patched__) return;

    Object.defineProperty(EventTarget.prototype, 'addEventListener', {
        value(type, fn, opts) {
            if (type === 'message') {
                const wrapped = ev => {
                    try {
                        if (typeof ev.data === 'string' && ev.target instanceof WebSocket) {
                            handleFrame(parseFrame(ev.data), ev.target);
                        }
                    } catch {}
                    return fn.call(this, ev);
                };
                return orig.call(this, type, wrapped, opts);
            }
            return orig.call(this, type, fn, opts);
        },
        configurable: false
    });
    orig.__patched__ = true;
})();

/* =========================
   Silence monitor
========================= */
setInterval(() => {
    if (performance.now() - lastMessageAt > 15000) {
        pendingClaims.clear();
    }
}, 5000);

/* =========================
   Stats exposure
========================= */
Object.defineProperty(window, '__RAIN_STATS__', {
    get() {
        let totalLatency = 0, counted = 0;
        for (const t of timing.byRain.values()) {
            if (t.seenAt && t.resultAt) {
                totalLatency += (t.resultAt - t.seenAt);
                counted++;
            }
        }
        return {
            frameId: FRAME_ID,
            ...stats,
            reconnects: wsState.reconnects,
            avgDowntimeMs: wsState.reconnects
                ? (wsState.totalDowntime / wsState.reconnects).toFixed(1)
                : '—',
            avgLatencyMs: counted
                ? (totalLatency / counted).toFixed(1)
                : '—',
            successRate: stats.claimsAttempted
                ? ((stats.claimsSucceeded / stats.claimsAttempted) * 100).toFixed(2) + '%'
                : '0%'
        };
    }
});

/* =========================
   iframe -> top stats relay
========================= */
if (!isTop) {
    setInterval(() => {
        try {
            window.top.postMessage({ type: 'RAIN_STATS', stats: window.__RAIN_STATS__ }, location.origin);
        } catch {}
    }, 500);
}

/* =========================
   Overlay (top window)
========================= */
if (isTop) (function overlay() {
    const frames = new Map();
    let pos = { x: 10, y: 10 }, drag = false, dx = 0, dy = 0;

    const el = document.createElement('div');
    el.style.cssText = `
        position: fixed;
        top: ${pos.y}px;
        left: ${pos.x}px;
        z-index: 2147483647;
        background: rgba(0,0,0,.8);
        color: #0f0;
        font: 12px monospace;
        padding: 8px 10px;
        border-radius: 6px;
        cursor: move;
        user-select: none;
        white-space: pre;
    `;
    document.documentElement.appendChild(el);

    el.addEventListener('mousedown', e => {
        drag = true;
        dx = e.clientX - pos.x;
        dy = e.clientY - pos.y;
        e.preventDefault();
    });
    window.addEventListener('mouseup', () => drag = false);
    window.addEventListener('mousemove', e => {
        if (!drag) return;
        pos.x = e.clientX - dx;
        pos.y = e.clientY - dy;
        el.style.left = pos.x + 'px';
        el.style.top = pos.y + 'px';
    });

    window.addEventListener('message', e => {
        if (e.origin !== location.origin) return;
        if (e.data?.type === 'RAIN_STATS') {
            frames.set(e.data.stats.frameId, e.data.stats);
        }
    });

    const render = () => {
        let t = { rainsSeen:0, claimsAttempted:0, claimsSucceeded:0, claimsFailed:0 };
        let latencySum = 0, latencyCount = 0, reconnects = 0;

        for (const s of frames.values()) {
            t.rainsSeen += s.rainsSeen;
            t.claimsAttempted += s.claimsAttempted;
            t.claimsSucceeded += s.claimsSucceeded;
            t.claimsFailed += s.claimsFailed;
            reconnects += s.reconnects || 0;
            if (s.avgLatencyMs !== '—') {
                latencySum += +s.avgLatencyMs;
                latencyCount++;
            }
        }

        el.textContent =
`RAIN AUTO-CLAIM
Frames: ${frames.size}
Seen: ${t.rainsSeen}
Attempted: ${t.claimsAttempted}
Success: ${t.claimsSucceeded}
Failed: ${t.claimsFailed}
Reconnects: ${reconnects}
Avg latency: ${latencyCount ? (latencySum/latencyCount).toFixed(1)+'ms' : '—'}`;

        requestAnimationFrame(render);
    };
    render();
})();

})();

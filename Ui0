// ==UserScript==
// @name         Universal Network Interceptor (Ultimate Version)
// @namespace    https://example.local/
// @version      8.0.0
// @description  Full monitoring, cloning, and replay for fetch, XHR, WebSocket, STOMP workflows. Includes GraphQL/binary support, chained workflows, replay features, and a UI overlay.
// @match        *://*/*
// @grant        none
// @run-at       document-start
// ==/UserScript==

(() => {
  "use strict";

  /**************************************************************************
   * Prevent Double Execution
   **************************************************************************/
  if (window.__UNIVERSAL_NETWORK_INTERCEPTOR_LOADED__) return;
  window.__UNIVERSAL_NETWORK_INTERCEPTOR_LOADED__ = true;

  console.info("[Universal Network Interceptor] Script Loaded");

  /**************************************************************************
   * Configuration and Data Storage
   **************************************************************************/
  const STORAGE = {
    CLONES: "uni_clones",
    LOGS: "uni_logs",
    SETTINGS: "uni_settings",
    WORKFLOWS: "uni_workflows",
  };

  const DEFAULTS = {
    maxLogs: 5000,
    maxClones: 500,
    blacklistPatterns: [],
    sizeLimitKB: 1024, // File payload size limit
  };

  let LOGS = loadJSON(STORAGE.LOGS, []);
  let CLONES = loadJSON(STORAGE.CLONES, []);
  let WORKFLOWS = loadJSON(STORAGE.WORKFLOWS, []);
  let SETTINGS = loadJSON(STORAGE.SETTINGS, DEFAULTS);

  /**************************************************************************
   * Utility Functions
   **************************************************************************/

  function nowIso() {
    return new Date().toISOString();
  }

  function uid() {
    return Math.random().toString(36).slice(2);
  }

  function loadJSON(key, fallback) {
    try {
      return JSON.parse(localStorage.getItem(key)) || fallback;
    } catch (e) {
      return fallback;
    }
  }

  function saveJSON(key, value) {
    localStorage.setItem(key, JSON.stringify(value));
  }

  function addLogEntry(entry) {
    LOGS.push(entry);
    while (LOGS.length > SETTINGS.maxLogs) LOGS.shift();
    saveJSON(STORAGE.LOGS, LOGS);
  }

  /**************************************************************************
   * Blob/Binary Data Utilities
   **************************************************************************/

  async function blobToBase64(blob) {
    const reader = new FileReader();
    return new Promise((resolve, reject) => {
      reader.onload = () => resolve(reader.result.split(",")[1] || ""); // Get base64 part
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }

  function base64ToBlob(base64, type = "application/octet-stream") {
    const binary = atob(base64);
    const len = binary.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
    return new Blob([bytes], { type });
  }

  /**************************************************************************
   * Workflow Manager
   **************************************************************************/

  const WorkflowManager = {
    workflows: WORKFLOWS,

    addWorkflow(request, response) {
      const workflow = {
        id: uid(),
        timestamp: nowIso(),
        steps: [
          {
            request,
            response,
          },
        ],
      };
      this.workflows.push(workflow);
      saveJSON(STORAGE.WORKFLOWS, this.workflows);
      console.info(`[Workflow] Captured new workflow: ${workflow.id}`);
      return workflow.id;
    },

    addStepToWorkflow(workflowId, request, response) {
      const workflow = this.workflows.find((w) => w.id === workflowId);
      if (!workflow) {
        console.error(`[Workflow] Workflow not found: ${workflowId}`);
        return;
      }
      workflow.steps.push({ request, response });
      saveJSON(STORAGE.WORKFLOWS, this.workflows);
      console.info(`[Workflow] Added new step to workflow: ${workflowId}`);
    },

    visualizeWorkflow(workflowId) {
      const workflow = this.workflows.find((w) => w.id === workflowId);
      if (!workflow) {
        console.error(`[Workflow] Cannot visualize workflow: ${workflowId}`);
        return;
      }

      console.group(`[Workflow Visualization] ${workflowId}`);
      workflow.steps.forEach((step, index) => {
        console.log(`Step ${index + 1}`);
        console.info("Request:", step.request);
        console.info("Response:", step.response);
      });
      console.groupEnd();
    },
  };

  /**************************************************************************
   * Interceptor: Fetch, XHR, WebSocket
   **************************************************************************/

  const Interceptor = {
    initialize() {
      this.hookFetch();
      this.hookXHR();
      this.hookWebSocket();
      console.info("[Interceptor] Initialized");
    },

    // Hook and log fetch calls
    hookFetch() {
      const originalFetch = window.fetch;

      window.fetch = async function (url, options = {}) {
        const requestMeta = {
          kind: "fetch",
          url,
          options,
          timestamp: nowIso(),
        };

        Interceptor.logRequest("fetch", requestMeta);

        const response = await originalFetch(url, options);
        const clonedResponse = response.clone();
        const responseMeta = {
          status: response.status,
          headers: Object.fromEntries(clonedResponse.headers.entries()),
          body: await clonedResponse.text(),
        };

        Interceptor.logResponse("fetch", {
          request: requestMeta,
          response: responseMeta,
        });

        // Automatically detect workflows (e.g., linking token fetching to subsequent requests)
        WorkflowManager.addWorkflow(requestMeta, responseMeta);

        return response;
      };
    },

    // Hook and log XHR
    hookXHR() {
      const OriginalXHR = window.XMLHttpRequest;

      function EnhancedXHR() {
        const xhr = new OriginalXHR();
        const requestMeta = { method: null, url: null, headers: {}, body: null };

        xhr.open = function (method, url, async = true, user, password) {
          requestMeta.method = method;
          requestMeta.url = url;
          OriginalXHR.prototype.open.call(this, method, url, async, user, password);
        };

        xhr.setRequestHeader = function (header, value) {
          requestMeta.headers[header] = value;
          OriginalXHR.prototype.setRequestHeader.call(this, header, value);
        };

        xhr.send = function (body) {
          requestMeta.body = body || null;
          Interceptor.logRequest("xhr", requestMeta);

          this.addEventListener("readystatechange", () => {
            if (this.readyState === 4) {
              const responseMeta = {
                status: this.status,
                headers: this.getAllResponseHeaders(),
                responseText: this.responseText,
              };
              Interceptor.logResponse("xhr", { request: requestMeta, response: responseMeta });
              WorkflowManager.addWorkflow(requestMeta, responseMeta);
            }
          });

          OriginalXHR.prototype.send.call(this, body);
        };

        return xhr;
      }

      window.XMLHttpRequest = EnhancedXHR;
    },

    // Hook and log WebSocket messages
    hookWebSocket() {
      const OriginalWebSocket = window.WebSocket;

      window.WebSocket = function (url, protocols) {
        const ws = protocols ? new OriginalWebSocket(url, protocols) : new OriginalWebSocket(url);

        ws.addEventListener("message", (event) => {
          Interceptor.logMessage("websocket", "received", event.data, url);
        });

        const originalSend = ws.send;
        ws.send = function (data) {
          Interceptor.logMessage("websocket", "sent", data, url);
          originalSend.call(ws, data);
        };

        return ws;
      };
    },

    logRequest(type, meta) {
      addLogEntry({
        id: uid(),
        timestamp: nowIso(),
        category: "request",
        type,
        meta,
      });
    },

    logResponse(type, meta) {
      addLogEntry({
        id: uid(),
        timestamp: nowIso(),
        category: "response",
        type,
        meta,
      });
    },

    logMessage(protocol, direction, payload, url) {
      addLogEntry({
        id: uid(),
        timestamp: nowIso(),
        category: `${protocol}-${direction}`,
        type: "message",
        meta: { payload, url },
      });
    },
  };

  /**************************************************************************
   * Initialize and Activate Interceptor
   **************************************************************************/
  Interceptor.initialize();
})();
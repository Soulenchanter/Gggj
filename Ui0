// ==UserScript==
// @name         Universal Network Interceptor (All-Inclusive)
// @namespace    https://example.local/
// @version      6.0.0
// @description  All-in-one network interceptor: fetch/XHR/WS/STOMP chaining, cloning, replaying, robust editing, and iframe-aware UI overlay.
// @match        *://*/*
// @grant        none
// @run-at       document-start
// ==/UserScript==

(() => {
  "use strict";

  /**************************************************************************
   * Prevent Double Load
   **************************************************************************/
  if (window.__UNIVERSAL_NETWORK_INTERCEPTOR_LOADED__) return;
  window.__UNIVERSAL_NETWORK_INTERCEPTOR_LOADED__ = true;

  /**************************************************************************
   * Core Configuration
   **************************************************************************/
  const STORAGE = {
    CLONES: "uni_ni_clones",
    LOGS: "uni_ni_logs",
  };

  const DEFAULTS = {
    maxLogs: 5000,
    maxClones: 500,
  };

  let LOGS = loadJSON(STORAGE.LOGS, []);
  let CLONES = loadJSON(STORAGE.CLONES, []);

  /**************************************************************************
   * Utilities
   **************************************************************************/
  function nowIso() {
    return new Date().toISOString();
  }

  function uid() {
    return Math.random().toString(36).slice(2, 9);
  }

  function loadJSON(key, fallback) {
    try {
      return JSON.parse(localStorage.getItem(key)) || fallback;
    } catch (e) {
      return fallback;
    }
  }

  function saveJSON(key, value) {
    localStorage.setItem(key, JSON.stringify(value));
  }

  function safeClone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }

  function pushLog(type, source, meta = {}) {
    const logEntry = { id: uid(), ts: nowIso(), type, source, meta };
    LOGS.push(logEntry);
    if (LOGS.length > DEFAULTS.maxLogs) LOGS.shift();
    saveJSON(STORAGE.LOGS, LOGS);
    console.debug("[Interceptor Log]", logEntry);
  }

  function addClone(clone) {
    if (!clone.id) clone.id = uid();
    CLONES.unshift(clone);
    if (CLONES.length > DEFAULTS.maxClones) CLONES.pop();
    saveJSON(STORAGE.CLONES, CLONES);
  }

  /**************************************************************************
   * Overlay UI: Logs and Clones Management
   **************************************************************************/
  const UI = {
    overlay: null,
    currentTab: "Logs",
    createOverlay() {
      const el = document.createElement("div");
      el.id = "ni-overlay";

      // UI Styles
      el.style.position = "fixed";
      el.style.bottom = "12px";
      el.style.right = "12px";
      el.style.width = "400px";
      el.style.height = "600px";
      el.style.zIndex = "999999999";
      el.style.background = "white";
      el.style.border = "1px solid black";
      el.style.overflow = "auto";

      document.body.appendChild(el);
      this.overlay = el;

      // Render the logs UI by default
      this.renderLogs();
    },
    renderLogs() {
      if (!this.overlay) this.createOverlay();

      this.overlay.innerHTML = "<h3>Logs</h3><ul>";
      LOGS.forEach((log) => {
        this.overlay.innerHTML += `<li>${log.ts} - ${log.type} - ${log.source}</li>`;
      });
      this.overlay.innerHTML += "</ul>";
    },
    renderClones() {
      if (!this.overlay) this.createOverlay();

      this.overlay.innerHTML = `<h3>Clones</h3>`;
      this.overlay.innerHTML += CLONES.map((clone) => `<div>${clone.request?.url || "Unknown URL"} [${clone.request?.kind || "Unknown"}]</div>`).join("");
    },
    switchToTab(tabName) {
      this.currentTab = tabName;
      if (tabName === "Logs") {
        this.renderLogs();
      } else if (tabName === "Clones") {
        this.renderClones();
      }
    },
  };

  /**************************************************************************
   * Request/Response Chaining and Cloning
   **************************************************************************/
  function createClone(request, response, linkedTo = null) {
    const cloneEntry = {
      id: uid(),
      ts: nowIso(),
      request: safeClone(request),
      response: safeClone(response),
      linkedTo: linkedTo || null, // ID of the linked clone
    };

    addClone(cloneEntry);
    pushLog("clone", "Created Clone", { request, response });
    return cloneEntry;
  }

  function replayClone(cloneId) {
    const clone = CLONES.find((c) => c.id === cloneId);
    if (!clone) {
      console.error(`Clone with ID ${cloneId} not found.`);
      return;
    }

    const { request } = clone;

    // Replay Fetch
    if (request.kind === "fetch") {
      pushLog("replay", "Replaying Fetch Clone", request);
      return window.fetch(request.url, request.options);
    }

    // Replay XHR
    if (request.kind === "xhr") {
      const xhr = new XMLHttpRequest();
      xhr.open(request.method, request.url, true);

      Object.keys(request.headers || {}).forEach((header) => xhr.setRequestHeader(header, request.headers[header]));

      xhr.onload = () => pushLog("replay", "XHR Response", { status: xhr.status, response: xhr.responseText });
      xhr.send(request.body || null);
      pushLog("replay", "Replayed XHR Request", request);
      return;
    }

    console.warn("Unsupported request type in replay:", request.kind);
  }

  function linkResponseToNextRequest(triggerResponse, nextRequestTemplate) {
    const linkedRequest = safeClone(nextRequestTemplate);

    // Insert dynamic authorization headers or tokens from the response
    if (triggerResponse.headers && triggerResponse.headers["Authorization"]) {
      linkedRequest.headers = linkedRequest.headers || {};
      linkedRequest.headers["Authorization"] = triggerResponse.headers["Authorization"];
    }

    return linkedRequest;
  }

  /**************************************************************************
   * Network Interception: Fetch, XHR, WebSocket
   **************************************************************************/
  const NetworkInterceptor = {
    interceptFetch() {
      const originalFetch = window.fetch;

      window.fetch = async function (url, options) {
        const requestMeta = { kind: "fetch", url, options };
        pushLog("log", "Fetch Sent", requestMeta);

        const response = await originalFetch(url, options);
        const clonedResponse = response.clone();

        const responseMeta = {
          status: clonedResponse.status,
          headers: Array.from(clonedResponse.headers.entries()),
          body: await clonedResponse.text(),
        };

        pushLog("log", "Fetch Response", responseMeta);
        createClone(requestMeta, responseMeta);

        return response; // Forward original response to the application
      };
    },

    interceptXHR() {
      const OriginalXHR = window.XMLHttpRequest;

      function EnhancedXHR() {
        const xhr = new OriginalXHR();
        const requestMeta = { kind: "xhr" };

        xhr.open = (method, url, async = true) => {
          requestMeta.method = method;
          requestMeta.url = url;
          return OriginalXHR.prototype.open.apply(xhr, arguments);
        };

        xhr.setRequestHeader = (header, value) => {
          requestMeta.headers = requestMeta.headers || {};
          requestMeta.headers[header] = value;
          return OriginalXHR.prototype.setRequestHeader.apply(xhr, arguments);
        };

        xhr.onreadystatechange = () => {
          if (xhr.readyState === 4) {
            const responseMeta = {
              status: xhr.status,
              responseText: xhr.responseText,
              headers: xhr.getAllResponseHeaders(),
            };

            pushLog("log", "XHR Response", responseMeta);
            createClone(requestMeta, responseMeta);
          }
        };

        xhr.send = (body) => {
          requestMeta.body = body || null;
          pushLog("log", "XHR Sent", requestMeta);
          return OriginalXHR.prototype.send.apply(xhr, arguments);
        };

        return xhr;
      }

      window.XMLHttpRequest = EnhancedXHR;
    },

    apply() {
      this.interceptFetch();
      this.interceptXHR();
    },
  };

  /**************************************************************************
   * Initialization
   **************************************************************************/
  NetworkInterceptor.apply();
  UI.createOverlay(); // Create default UI overlay for logs/clones
})();
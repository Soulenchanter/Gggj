(function () {
'use strict';

/* ============================================================
   SCRIPT EXECUTOR PRO — FINAL
   ============================================================ */

/* ================= CONFIG ================= */
const CONFIG = {
    storageKey: 'se_snippets_final',
    githubTokenKey: 'se_github_token',
    githubApi: 'https://api.github.com',
    repoDir: 'script-executor',
    autoSyncOnLoad: true,
    autoSyncDelay: 1500,
    idleDelay: 20000
};

/* ================= STATE ================= */
const state = {
    snippets: {},
    frames: {},
    idleTimer: null,
    github: {
        user: null,
        repos: [],
        repo: null,
        branch: 'main',
        autoSync: true
    }
};

/* ================= UTILS ================= */
const U = {
    save() {
        localStorage.setItem(CONFIG.storageKey, JSON.stringify(state.snippets));
    },
    load() {
        return JSON.parse(localStorage.getItem(CONFIG.storageKey) || '{}');
    },
    token: {
        get: () => localStorage.getItem(CONFIG.githubTokenKey),
        set: t => t
            ? localStorage.setItem(CONFIG.githubTokenKey, t)
            : localStorage.removeItem(CONFIG.githubTokenKey)
    },
    log(msg, type = 'info') {
        const el = document.createElement('div');
        el.className = `log ${type}`;
        el.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
        document.getElementById('log').appendChild(el);
    },
    b64enc(s) {
        return btoa(unescape(encodeURIComponent(s)));
    },
    b64dec(s) {
        return decodeURIComponent(escape(atob(s)));
    }
};

/* ================= EXECUTION ================= */
function execute(code, ctx) {
    try {
        if (!ctx || ctx === 'top') eval(code);
        else state.frames[ctx]?.contentWindow.eval(code);
        U.log('Executed', 'ok');
    } catch (e) {
        U.log(e.message, 'err');
    }
}

/* ================= GITHUB ================= */
const GitHub = {
    headers() {
        return {
            Authorization: `token ${U.token.get()}`,
            Accept: 'application/vnd.github+json'
        };
    },

    async api(path, opts = {}) {
        const r = await fetch(CONFIG.githubApi + path, {
            ...opts,
            headers: { ...this.headers(), ...(opts.headers || {}) }
        });
        if (!r.ok) throw new Error(await r.text());
        return r.json();
    },

    async connect() {
        const t = prompt('Paste GitHub PAT (repo scope)');
        if (!t) return;
        U.token.set(t);
        state.github.user = await this.api('/user');
        state.github.repos = await this.api('/user/repos?per_page=100');
        renderRepos();
        U.log(`Connected as ${state.github.user.login}`, 'ok');
    },

    async push() {
        if (!state.github.repo) return alert('Select repo');
        for (const [name, s] of Object.entries(state.snippets)) {
            const path = `${CONFIG.repoDir}/${name}.js`;
            const content = U.b64enc(s.code);
            let sha;

            try {
                const f = await this.api(`/repos/${state.github.repo}/contents/${path}?ref=${state.github.branch}`);
                sha = f.sha;
            } catch {}

            await this.api(`/repos/${state.github.repo}/contents/${path}`, {
                method: 'PUT',
                body: JSON.stringify({
                    message: `Update ${name}`,
                    content,
                    branch: state.github.branch,
                    sha
                })
            });
        }
        U.log('Pushed to GitHub', 'ok');
    },

    async pull() {
        if (!state.github.repo) return;
        const files = await this.api(
            `/repos/${state.github.repo}/contents/${CONFIG.repoDir}?ref=${state.github.branch}`
        );

        for (const f of files.filter(x => x.name.endsWith('.js'))) {
            const data = await this.api(`/repos/${state.github.repo}/contents/${f.path}`);
            const remote = U.b64dec(data.content);
            const name = f.name.replace(/\.js$/, '');
            const local = state.snippets[name]?.code;

            if (!local || local === remote) {
                state.snippets[name] = { code: remote };
            } else {
                Diff.prompt(name, local, remote);
            }
        }
        U.save();
        renderList();
        U.log('Pull complete', 'ok');
    }
};

/* ================= DIFF ================= */
const Diff = {
    prompt(name, local, remote) {
        const w = window.open('', '_blank', 'width=900,height=600');
        w.document.write(`
<style>
body{font-family:monospace;display:flex}
pre{width:50%;padding:10px;overflow:auto}
.l{background:#fee2e2}.r{background:#dcfce7}
button{position:fixed;bottom:10px;left:10px}
</style>
<pre class="l">${esc(local)}</pre>
<pre class="r">${esc(remote)}</pre>
<button>Overwrite</button>
`);
        w.document.querySelector('button').onclick = () => {
            state.snippets[name] = { code: remote };
            U.save();
            renderList();
            w.close();
        };
    }
};

function esc(s) {
    return s.replace(/[&<>]/g, c =>
        ({ '&': '&amp;', '<': '&lt;', '>': '&gt;' }[c])
    );
}

/* ================= UI ================= */
function UI() {
document.body.insertAdjacentHTML('beforeend', `
<style>
#se{position:fixed;bottom:10px;right:10px;width:420px;height:520px;
background:#fff;border-radius:12px;box-shadow:0 20px 40px #0003;
font-family:sans-serif;z-index:999999;display:flex;flex-direction:column}
#se h{background:#6366f1;color:#fff;padding:10px;font-weight:700;cursor:move}
#se c{flex:1;padding:10px;overflow:auto}
textarea{width:100%;height:120px}
.log.ok{color:green}.log.err{color:red}
</style>

<div id="se">
<h>Script Executor Pro</h>
<c>
<input id="name" placeholder="Snippet name"><br>
<textarea id="code"></textarea>
<button id="save">Save</button>
<button id="run">Run</button>
<hr>
<button id="gh">GitHub</button>
<button id="push">Push</button>
<button id="pull">Pull</button>
<button id="autosync">AutoSync: ON</button>
<br>
<select id="repo"></select>
<input id="branch" value="main">
<hr>
<div id="list"></div>
<hr>
<div id="log"></div>
</c>
</div>
`);
}

/* ================= RENDER ================= */
function renderList() {
    const l = document.getElementById('list');
    l.innerHTML = '';
    Object.entries(state.snippets).forEach(([k, v]) => {
        const d = document.createElement('div');
        d.innerHTML = `<b>${k}</b> <button>▶</button> <button>✕</button>`;
        const [r, x] = d.querySelectorAll('button');
        r.onclick = () => execute(v.code, 'top');
        x.onclick = () => {
            delete state.snippets[k];
            U.save();
            renderList();
        };
        l.appendChild(d);
    });
}

function renderRepos() {
    const s = document.getElementById('repo');
    s.innerHTML = '';
    state.github.repos.forEach(r => {
        const o = document.createElement('option');
        o.value = r.full_name;
        o.textContent = r.full_name;
        s.appendChild(o);
    });
    s.onchange = e => state.github.repo = e.target.value;
    state.github.repo = s.value;
}

/* ================= AUTO SYNC ================= */
async function autoSync() {
    if (!CONFIG.autoSyncOnLoad) return;
    if (!state.github.autoSync) return;
    if (!U.token.get()) return;
    try {
        await GitHub.pull();
        U.log('Auto-sync done', 'ok');
    } catch (e) {
        U.log('Auto-sync failed', 'err');
    }
}

/* ================= INIT ================= */
function init() {
    UI();
    state.snippets = U.load();
    renderList();

    document.getElementById('save').onclick = () => {
        state.snippets[name.value] = { code: code.value };
        U.save();
        renderList();
    };

    document.getElementById('run').onclick = () => execute(code.value, 'top');
    document.getElementById('gh').onclick = () => GitHub.connect();
    document.getElementById('push').onclick = () => GitHub.push();
    document.getElementById('pull').onclick = () => GitHub.pull();

    document.getElementById('autosync').onclick = e => {
        state.github.autoSync = !state.github.autoSync;
        e.target.textContent =
            'AutoSync: ' + (state.github.autoSync ? 'ON' : 'OFF');
    };

    setTimeout(autoSync, CONFIG.autoSyncDelay);
}

init();
})();
